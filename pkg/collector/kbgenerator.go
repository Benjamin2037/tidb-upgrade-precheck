// Package collector provides knowledge base generation and loading functionality
package collector

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// LoadKnowledgeBase loads knowledge base for all components (tidb, pd, tikv, tiflash) for a specific version
// Returns a map with component keys containing config_defaults, system_variables, and upgrade_logic
// Also loads global high_risk_params configuration (high_risk_params.json)
// This function loads the knowledge base that was generated by the kbgenerator
func LoadKnowledgeBase(knowledgeBasePath, version string) (map[string]interface{}, error) {
	kb := make(map[string]interface{})

	// Get version group from full version (e.g., v7.5.1 -> v7.5)
	// Version is always a full three-digit version (e.g., v7.5.1, v6.5.0)
	versionGroup := getVersionGroup(version)

	// Load knowledge base for each component
	components := []string{"tidb", "pd", "tikv", "tiflash"}
	for _, component := range components {
		componentKB := make(map[string]interface{})

		// Load defaults.json
		defaultsPath := filepath.Join(knowledgeBasePath, versionGroup, version, component, "defaults.json")
		if _, err := os.Stat(defaultsPath); err == nil {
			data, err := os.ReadFile(defaultsPath)
			if err != nil {
				return nil, fmt.Errorf("failed to read defaults file %s: %w", defaultsPath, err)
			}

			var defaults map[string]interface{}
			if err := json.Unmarshal(data, &defaults); err != nil {
				return nil, fmt.Errorf("failed to parse defaults file %s: %w", defaultsPath, err)
			}

			// Load all fields from defaults.json without filtering
			// This ensures all data in the knowledge base is preserved
			for key, value := range defaults {
				componentKB[key] = value
			}
		}

		// Load upgrade_logic.json (component-specific, global location)
		// upgrade_logic.json is version-agnostic and stored at knowledgeBasePath/component/upgrade_logic.json
		upgradeLogicPath := filepath.Join(knowledgeBasePath, component, "upgrade_logic.json")
		if _, err := os.Stat(upgradeLogicPath); err == nil {
			data, err := os.ReadFile(upgradeLogicPath)
			if err == nil {
				var upgradeLogic interface{}
				if err := json.Unmarshal(data, &upgradeLogic); err == nil {
					componentKB["upgrade_logic"] = upgradeLogic
				}
			}
		}

		// Only add component to KB if it has data
		if len(componentKB) > 0 {
			kb[component] = componentKB
		}
	}

	// Load high_risk_params.json (global, version-agnostic)
	// This file contains high-risk parameters configuration for all components
	highRiskParamsPath := filepath.Join(knowledgeBasePath, "high_risk_params", "high_risk_params.json")
	if _, err := os.Stat(highRiskParamsPath); err == nil {
		data, err := os.ReadFile(highRiskParamsPath)
		if err == nil {
			var highRiskParams interface{}
			if err := json.Unmarshal(data, &highRiskParams); err == nil {
				kb["high_risk_params"] = highRiskParams
			}
		}
	}

	// Load parameter_notes.json (global, version-agnostic)
	// This file contains special notes/descriptions for parameters
	parameterNotesPath := filepath.Join(knowledgeBasePath, "parameter_notes.json")
	if _, err := os.Stat(parameterNotesPath); err == nil {
		data, err := os.ReadFile(parameterNotesPath)
		if err == nil {
			var parameterNotes interface{}
			if err := json.Unmarshal(data, &parameterNotes); err == nil {
				kb["parameter_notes"] = parameterNotes
			}
		}
	}

	return kb, nil
}

// getVersionGroup extracts the version group (first two digits) from a full version string
// Input version is always a full three-digit version (e.g., v7.5.1, v6.5.0, v8.5.2)
// Example: v7.5.1 -> v7.5, v6.5.0 -> v6.5, v8.5.2 -> v8.5
// This is used to construct the knowledge base path: knowledge/<version-group>/<full-version>/<component>/defaults.json
func getVersionGroup(version string) string {
	// Remove 'v' prefix if present
	version = strings.TrimPrefix(version, "v")

	// Split by '.' and take first two parts
	parts := strings.Split(version, ".")
	if len(parts) >= 2 {
		return "v" + parts[0] + "." + parts[1]
	}
	// Fallback: if version doesn't have expected format, return as is
	return "v" + version
}
