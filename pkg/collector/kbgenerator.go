// Package collector provides knowledge base generation and loading functionality
package collector

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// LoadKnowledgeBase loads knowledge base for all components (tidb, pd, tikv, tiflash) for a specific version
// Returns a map with component keys containing config_defaults, system_variables, and upgrade_logic
// This function loads the knowledge base that was generated by the kbgenerator
func LoadKnowledgeBase(knowledgeBasePath, version string) (map[string]interface{}, error) {
	kb := make(map[string]interface{})

	// Get version group from full version (e.g., v7.5.1 -> v7.5)
	// Version is always a full three-digit version (e.g., v7.5.1, v6.5.0)
	versionGroup := getVersionGroup(version)

	// Load knowledge base for each component
	components := []string{"tidb", "pd", "tikv", "tiflash"}
	for _, component := range components {
		componentKB := make(map[string]interface{})

		// Load defaults.json
		defaultsPath := filepath.Join(knowledgeBasePath, versionGroup, version, component, "defaults.json")
		if _, err := os.Stat(defaultsPath); err == nil {
			data, err := os.ReadFile(defaultsPath)
			if err != nil {
				return nil, fmt.Errorf("failed to read defaults file %s: %w", defaultsPath, err)
			}

			var defaults map[string]interface{}
			if err := json.Unmarshal(data, &defaults); err != nil {
				return nil, fmt.Errorf("failed to parse defaults file %s: %w", defaultsPath, err)
			}

			// Extract config_defaults, system_variables, and bootstrap_version
			if configDefaults, ok := defaults["config_defaults"].(map[string]interface{}); ok {
				componentKB["config_defaults"] = configDefaults
			}
			if systemVars, ok := defaults["system_variables"].(map[string]interface{}); ok {
				componentKB["system_variables"] = systemVars
			}
			// Extract bootstrap_version (important for filtering upgrade logic by bootstrap version range)
			if bootstrapVersion, ok := defaults["bootstrap_version"]; ok {
				componentKB["bootstrap_version"] = bootstrapVersion
			}
		}

		// Load upgrade_logic.json (component-specific, global location)
		// upgrade_logic.json is version-agnostic and stored at knowledgeBasePath/component/upgrade_logic.json
		upgradeLogicPath := filepath.Join(knowledgeBasePath, component, "upgrade_logic.json")
		if _, err := os.Stat(upgradeLogicPath); err == nil {
			data, err := os.ReadFile(upgradeLogicPath)
			if err == nil {
				var upgradeLogic interface{}
				if err := json.Unmarshal(data, &upgradeLogic); err == nil {
					componentKB["upgrade_logic"] = upgradeLogic
					fmt.Printf("[DEBUG LoadKnowledgeBase] Loaded upgrade_logic for %s from %s\n", component, upgradeLogicPath)
				} else {
					fmt.Printf("[DEBUG LoadKnowledgeBase] Failed to unmarshal upgrade_logic for %s: %v\n", component, err)
				}
			} else {
				fmt.Printf("[DEBUG LoadKnowledgeBase] Failed to read upgrade_logic for %s: %v\n", component, err)
			}
		} else {
			fmt.Printf("[DEBUG LoadKnowledgeBase] upgrade_logic.json not found for %s at %s\n", component, upgradeLogicPath)
		}

		// Only add component to KB if it has data
		if len(componentKB) > 0 {
			kb[component] = componentKB
		}
	}

	return kb, nil
}

// getVersionGroup extracts the version group (first two digits) from a full version string
// Input version is always a full three-digit version (e.g., v7.5.1, v6.5.0, v8.5.2)
// Example: v7.5.1 -> v7.5, v6.5.0 -> v6.5, v8.5.2 -> v8.5
// This is used to construct the knowledge base path: knowledge/<version-group>/<full-version>/<component>/defaults.json
func getVersionGroup(version string) string {
	// Remove 'v' prefix if present
	version = strings.TrimPrefix(version, "v")

	// Split by '.' and take first two parts
	parts := strings.Split(version, ".")
	if len(parts) >= 2 {
		return "v" + parts[0] + "." + parts[1]
	}
	// Fallback: if version doesn't have expected format, return as is
	return "v" + version
}
