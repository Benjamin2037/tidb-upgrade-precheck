diff --git a/go.mod b/go.mod
index xxxxxxx..xxxxxxx 100644
--- a/go.mod
+++ b/go.mod
@@ -20,6 +20,7 @@ require (
        github.com/pingcap/ng-monitoring v0.0.0-20230821071418-dbc1bd957302
        github.com/pingcap/tiup v1.11.0
        github.com/pingcap/tiup/pkg v0.0.0-00010101000000-000000000000
+       github.com/pingcap/tidb-upgrade-precheck v0.1.0
        github.com/pkg/errors v0.9.1
        github.com/prometheus/client_golang v1.11.1
        github.com/sergi/go-diff v1.2.0

diff --git a/cmd/cluster/command/upgrade.go b/cmd/cluster/command/upgrade.go
index xxxxxxx..xxxxxxx 100644
--- a/cmd/cluster/command/upgrade.go
+++ b/cmd/cluster/command/upgrade.go
@@ -22,6 +22,10 @@ import (
        "github.com/pingcap/tiup/pkg/cluster/spec"
        "github.com/pingcap/tiup/pkg/environment"
        "github.com/pingcap/tiup/pkg/utils"
+       precheckRuntime "github.com/pingcap/tidb-upgrade-precheck/pkg/runtime"
+       precheckEngine "github.com/pingcap/tidb-upgrade-precheck/pkg/precheck"
+       precheckReport "github.com/pingcap/tidb-upgrade-precheck/pkg/report"
+       "github.com/pingcap/tidb-upgrade-precheck/pkg/runtime/types"
 )
 
 func NewUpgradeCmd() *cobra.Command {
@@ -45,6 +49,10 @@ func NewUpgradeCmd() *cobra.Command {
                }),
        }
 
+       // Add precheck flags
+       cmd.Flags().Bool("precheck", false, "Perform compatibility check and ask user for confirmation")
+       cmd.Flags().Bool("without-precheck", false, "Skip compatibility check and proceed directly to upgrade")
+
        return cmd
 }
 
@@ -60,6 +68,77 @@ func upgradeCluster(clusterName, version string, opt operator.Options) error {
                return err
        }
 
+       // Check if precheck should be skipped
+       withoutPrecheck, err := cmd.Flags().GetBool("without-precheck")
+       if err != nil {
+               return err
+       }
+
+       // Check if explicit precheck is requested
+       explicitPrecheck, err := cmd.Flags().GetBool("precheck")
+       if err != nil {
+               return err
+       }
+
+       // Run precheck if explicitly requested or if neither precheck nor without-precheck is specified (default behavior)
+       if explicitPrecheck || (!explicitPrecheck && !withoutPrecheck) {
+               if err := runPrecheck(topo, clusterName, version); err != nil {
+                       return fmt.Errorf("precheck failed: %v", err)
+               }
+
+               // Ask for user confirmation if not explicitly requesting precheck
+               if !explicitPrecheck {
+                       if !askUserConfirmation() {
+                               fmt.Println("Upgrade cancelled by user.")
+                               return nil
+                       }
+               }
+       }
+
        if !opt.Force {
                if err := checkMultiDC(topo); err != nil {
                        return err
@@ -200,3 +279,90 @@ func confirmTopology(clusterName, version string, topo *spec.Specification) error
        }
        return nil
 }
+
+func runPrecheck(topo *spec.Specification, clusterName, targetVersion string) error {
+       // Convert TiUP topology to endpoints format required by tidb-upgrade-precheck
+       endpoints := convertToEndpoint(topo)
+
+       // Initialize collector
+       collector := precheckRuntime.NewCollector()
+
+       // Collect cluster snapshot
+       snapshot, err := collector.Collect(endpoints)
+       if err != nil {
+               return fmt.Errorf("failed to collect cluster information: %v", err)
+       }
+
+       // Set version information
+       snapshot.SourceVersion = getCurrentVersion(topo) // Implement this function to get current version
+       snapshot.TargetVersion = targetVersion
+
+       // Run precheck analysis
+       reportData := precheckEngine.FromClusterSnapshot(snapshot)
+
+       // Generate report
+       generator := precheckReport.NewGenerator()
+       options := &precheckReport.Options{
+               Format:    precheckReport.TextFormat,
+               OutputDir: "./",
+       }
+
+       reportPath, err := generator.Generate(reportData, options)
+       if err != nil {
+               return fmt.Errorf("failed to generate precheck report: %v", err)
+       }
+
+       fmt.Printf("Precheck report generated: %s\n", reportPath)
+
+       return nil
+}
+
+// Convert TiUP topology to endpoints
+func convertToEndpoint(topo *spec.Specification) types.ClusterEndpoints {
+       endpoints := types.ClusterEndpoints{}
+
+       // Get TiDB address
+       for _, comp := range topo.ComponentsByStartOrder() {
+               if comp.Name() == spec.ComponentTiDB {
+                       inst := comp.Instances()[0] // Get the first instance for simplicity
+                       endpoints.TiDBAddr = fmt.Sprintf("%s:%d", inst.GetHost(), inst.GetPort())
+                       break
+               }
+       }
+
+       // Get TiKV addresses
+       for _, comp := range topo.ComponentsByStartOrder() {
+               if comp.Name() == spec.ComponentTiKV {
+                       for _, inst := range comp.Instances() {
+                               endpoints.TiKVAddrs = append(endpoints.TiKVAddrs,
+                                       fmt.Sprintf("%s:%d", inst.GetHost(), inst.GetPort()))
+                       }
+               }
+       }
+
+       // Get PD addresses
+       for _, comp := range topo.ComponentsByStartOrder() {
+               if comp.Name() == spec.ComponentPD {
+                       for _, inst := range comp.Instances() {
+                               endpoints.PDAddrs = append(endpoints.PDAddrs,
+                                       fmt.Sprintf("%s:%d", inst.GetHost(), inst.GetPort()))
+                       }
+               }
+       }
+
+       return endpoints
+}
+
+// Get current cluster version
+func getCurrentVersion(topo *spec.Specification) string {
+       // Implementation to get current version from topology
+       // This might involve querying the cluster or checking component versions
+       // For now, return a placeholder
+       return "unknown"
+}
+
+// Ask user for confirmation
+func askUserConfirmation() bool {
+       reader := bufio.NewReader(os.Stdin)
+       fmt.Print("Precheck completed. Do you want to continue with the upgrade? (Y/n): ")
+       response, err := reader.ReadString('\n')
+       if err != nil {
+               return false
+       }
+
+       response = strings.ToLower(strings.TrimSpace(response))
+       return response == "y" || response == "yes" || response == ""
+}